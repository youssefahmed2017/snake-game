import React, { useState, useEffect, useCallback, useRef } from 'react';
import * as Tone from 'tone';

const GRID_SIZE = 20;
const CELL_SIZE = 20;
const INITIAL_SNAKE = [[10, 10]];
const INITIAL_DIRECTION = { x: 1, y: 0 };
const INITIAL_SPEED = 150;

const COLORS = {
  red: '#ef4444',
  yellow: '#eab308',
  blue: '#3b82f6',
  black: '#1f2937',
  green: '#10b981'
};

const PATTERNS = {
  squares: 'â– ',
  rectangles: 'â–¬',
  triangles: 'â–²',
  stars: 'â˜…'
};

const SnakeLogo = () => (
  <svg width="120" height="120" viewBox="0 0 120 120" className="mx-auto mb-4">
    <path
      d="M 20 60 Q 30 40, 40 50 Q 50 60, 60 50 Q 70 40, 80 50 Q 90 60, 100 50"
      stroke="#10b981"
      strokeWidth="12"
      fill="none"
      strokeLinecap="round"
      strokeLinejoin="round"
    />
    <circle cx="100" cy="50" r="8" fill="#10b981" />
    <circle cx="95" cy="45" r="2" fill="white" />
    <circle cx="20" cy="60" r="6" fill="#ef4444" />
  </svg>
);

export default function SnakeGame() {
  const [gameState, setGameState] = useState<'menu' | 'playing' | 'customize'>('menu');
  const [gameMode, setGameMode] = useState<'classic' | 'speed' | 'hard' | 'endless-classic' | 'endless-speedy' | 'endless-hard' | 'uncompromising'>('classic');
  const [snake, setSnake] = useState<number[][]>(INITIAL_SNAKE);
  const [food, setFood] = useState<number[]>([5, 5]);
  const [direction, setDirection] = useState<{ x: number; y: number }>(INITIAL_DIRECTION);
  const [gameOver, setGameOver] = useState(false);
  const [score, setScore] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [lives, setLives] = useState(0);
  const [showRevive, setShowRevive] = useState(false);
  const [currentSpeed, setCurrentSpeed] = useState(INITIAL_SPEED);
  const [isSlowdown, setIsSlowdown] = useState(false);
  const [isSpeedBoost, setIsSpeedBoost] = useState(false);
  const [unlockedModes, setUnlockedModes] = useState<string[]>(['classic']);
  const [highScores, setHighScores] = useState<Record<string, number>>({
    classic: 0,
    speed: 0,
    hard: 0,
    'endless-classic': 0,
    'endless-speedy': 0,
    'endless-hard': 0,
    uncompromising: 0
  });
  const [snakeColor, setSnakeColor] = useState<keyof typeof COLORS>('green');
  const [snakePattern, setSnakePattern] = useState<keyof typeof PATTERNS>('squares');

  const synthRef = useRef<Tone.Synth | null>(null);
  const slowdownTimerRef = useRef<number | null>(null);
  const speedBoostTimerRef = useRef<number | null>(null);

  // audio started flag (must be true after a user gesture)
  const [audioStarted, setAudioStarted] = useState(false);

  // safe storage helpers (fall back to localStorage)
  const safeGet = async (key: string) => {
    try {
      // window.storage exists in some embed environments â€” keep compatibility
      if ((window as any).storage && typeof (window as any).storage.get === 'function') {
        return await (window as any).storage.get(key);
      }
      const raw = localStorage.getItem(key);
      return raw ? { value: raw } : null;
    } catch (e) {
      console.warn('safeGet error', e);
      return null;
    }
  };

  const safeSet = async (key: string, value: any) => {
    try {
      if ((window as any).storage && typeof (window as any).storage.set === 'function') {
        return await (window as any).storage.set(key, value);
      }
      localStorage.setItem(key, value);
      return true;
    } catch (e) {
      console.warn('safeSet error', e);
      return false;
    }
  };

  useEffect(() => {
    const loadData = async () => {
      try {
        const modesResult = await safeGet('unlocked-modes');
        if (modesResult) {
          const parsed = typeof modesResult.value === 'string' ? JSON.parse(modesResult.value) : modesResult.value;
          setUnlockedModes(parsed);
        }
      } catch (e) {
        console.log('No saved modes yet');
      }

      try {
        const scoresResult = await safeGet('high-scores');
        if (scoresResult) {
          const parsed = typeof scoresResult.value === 'string' ? JSON.parse(scoresResult.value) : scoresResult.value;
          setHighScores(parsed);
        }
      } catch (e) {
        console.log('No saved scores yet');
      }

      try {
        const customResult = await safeGet('snake-customization');
        if (customResult) {
          const custom = typeof customResult.value === 'string' ? JSON.parse(customResult.value) : customResult.value;
          setSnakeColor((custom.color as keyof typeof COLORS) || 'green');
          setSnakePattern((custom.pattern as keyof typeof PATTERNS) || 'squares');
        }
      } catch (e) {
        console.log('No saved customization yet');
      }
    };
    loadData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  // --- Audio initialization after a user gesture ---
  const initAudioIfNeeded = async () => {
    try {
      if (!audioStarted) {
        await Tone.start(); // must be called in user gesture
        synthRef.current = new Tone.Synth().toDestination();
        setAudioStarted(true);
        console.log('Audio started');
      }
    } catch (err) {
      console.warn('Audio init error', err);
    }
  };

  useEffect(() => {
    return () => {
      if (synthRef.current) {
        try {
          synthRef.current.dispose();
        } catch (e) {
          /* ignore */
        }
      }
      if (slowdownTimerRef.current) window.clearTimeout(slowdownTimerRef.current);
      if (speedBoostTimerRef.current) window.clearTimeout(speedBoostTimerRef.current);
    };
  }, []);

  // play sounds (ensure audio started)
  const playEatSound = async () => {
    await initAudioIfNeeded();
    if (synthRef.current) synthRef.current.triggerAttackRelease('C5', '0.1');
  };

  const playLifeSound = async () => {
    await initAudioIfNeeded();
    if (synthRef.current) {
      synthRef.current.triggerAttackRelease('C5', '0.08', Tone.now());
      synthRef.current.triggerAttackRelease('E5', '0.08', Tone.now() + 0.08);
      synthRef.current.triggerAttackRelease('G5', '0.08', Tone.now() + 0.16);
      synthRef.current.triggerAttackRelease('C6', '0.12', Tone.now() + 0.24);
      synthRef.current.triggerAttackRelease('E6', '0.15', Tone.now() + 0.36);
    }
  };

  const playGameOverSound = async () => {
    await initAudioIfNeeded();
    if (synthRef.current) {
      synthRef.current.triggerAttackRelease('C4', '0.2', Tone.now());
      synthRef.current.triggerAttackRelease('G3', '0.2', Tone.now() + 0.15);
      synthRef.current.triggerAttackRelease('E3', '0.4', Tone.now() + 0.3);
    }
  };

  const playUnlockSound = async () => {
    await initAudioIfNeeded();
    if (synthRef.current) {
      synthRef.current.triggerAttackRelease('C5', '0.1');
      setTimeout(() => synthRef.current && synthRef.current.triggerAttackRelease('E5', '0.1'), 100);
      setTimeout(() => synthRef.current && synthRef.current.triggerAttackRelease('G5', '0.2'), 200);
    }
  };

  const generateFood = useCallback(() => {
    let newFood: number[] = [];
    do {
      newFood = [Math.floor(Math.random() * GRID_SIZE), Math.floor(Math.random() * GRID_SIZE)];
    } while (snake.some((segment) => segment[0] === newFood[0] && segment[1] === newFood[1]));
    return newFood;
  }, [snake]);

  const getInitialSpeed = (mode: string) => {
    if (mode === 'speed') return INITIAL_SPEED / 1.3; // 130% speed
    if (mode === 'endless-speedy') return INITIAL_SPEED / 1.5; // 150% speed
    if (mode === 'hard' || mode === 'endless-hard') return INITIAL_SPEED / 1.45; // 145% speed
    if (mode === 'uncompromising') return INITIAL_SPEED / 1.75; // 175% speed
    return INITIAL_SPEED;
  };

  const resetGame = () => {
    const initialSpeed = getInitialSpeed(gameMode);
    setSnake(INITIAL_SNAKE);
    setDirection(INITIAL_DIRECTION);
    setFood([5, 5]);
    setScore(0);
    setLives(0);
    setGameOver(false);
    setShowRevive(false);
    setIsPlaying(true);
    setCurrentSpeed(initialSpeed);
    setIsSlowdown(false);
    setIsSpeedBoost(false);
    if (slowdownTimerRef.current) window.clearTimeout(slowdownTimerRef.current);
    if (speedBoostTimerRef.current) window.clearTimeout(speedBoostTimerRef.current);
  };

  const startGame = (mode: any) => {
    setGameMode(mode);
    const initialSpeed = getInitialSpeed(mode);
    setCurrentSpeed(initialSpeed);
    setSnake(INITIAL_SNAKE);
    setDirection(INITIAL_DIRECTION);
    setFood([5, 5]);
    setScore(0);
    setLives(0);
    setGameOver(false);
    setShowRevive(false);
    setIsPlaying(true);
    setIsSlowdown(false);
    setIsSpeedBoost(false);
    setGameState('playing');
  };

  const quitToMenu = () => {
    setGameState('menu');
    setGameOver(false);
    setIsPlaying(false);
  };

  const unlockMode = async (mode: string) => {
    if (!unlockedModes.includes(mode)) {
      const newModes = [...unlockedModes, mode];
      setUnlockedModes(newModes);
      playUnlockSound();
      try {
        await safeSet('unlocked-modes', JSON.stringify(newModes));
      } catch (e) {
        console.error('Failed to save unlocked modes', e);
      }
    }
  };

  const updateHighScore = async (mode: string, newScore: number) => {
    if (newScore > (highScores as any)[mode]) {
      const newHighScores = { ...highScores, [mode]: newScore };
      setHighScores(newHighScores);
      try {
        await safeSet('high-scores', JSON.stringify(newHighScores));
      } catch (e) {
        console.error('Failed to save high scores', e);
      }
    }
  };

  const handleDirectionChange = (newDir: { x: number; y: number }) => {
    if (!isPlaying && gameState === 'playing') {
      setIsPlaying(true);
    }

    if (newDir.x !== 0 && direction.x === 0) {
      setDirection(newDir);
    } else if (newDir.y !== 0 && direction.y === 0) {
      setDirection(newDir);
    }
  };

  const handleSpacePress = () => {
    if (showRevive && lives > 0) {
      setLives((l) => l - 1);
      setShowRevive(false);
      setSnake(INITIAL_SNAKE);
      setDirection(INITIAL_DIRECTION);
    } else if (gameOver) {
      resetGame();
    }
  };
  const moveSnake = useCallback(() => {
    if (gameOver || !isPlaying || showRevive) return;

    const newSnake = [...snake];
    const head = newSnake[0];
    const newHead = [head[0] + direction.x, head[1] + direction.y];

    if (newHead[0] < 0 || newHead[0] >= GRID_SIZE || newHead[1] < 0 || newHead[1] >= GRID_SIZE) {
      if (lives > 0) {
        setShowRevive(true);
        return;
      }
      playGameOverSound();
      setGameOver(true);
      setIsPlaying(false);
      updateHighScore(gameMode, score);
      return;
    }

    if (newSnake.some((segment) => segment[0] === newHead[0] && segment[1] === newHead[1])) {
      if (lives > 0) {
        setShowRevive(true);
        return;
      }
      playGameOverSound();
      setGameOver(true);
      setIsPlaying(false);
      updateHighScore(gameMode, score);
      return;
    }

    newSnake.unshift(newHead);

    if (newHead[0] === food[0] && newHead[1] === food[1]) {
      const newScore = score + 10;
      setScore(newScore);
      playEatSound();

      let lifeThreshold = 150;
      if (gameMode === 'hard' || gameMode === 'endless-hard') {
        lifeThreshold = 200;
      } else if (gameMode === 'endless-classic') {
        lifeThreshold = 200;
      } else if (gameMode === 'uncompromising') {
        lifeThreshold = 350;
      }

      if (Math.floor(newScore / lifeThreshold) > Math.floor(score / lifeThreshold)) {
        setLives((l) => l + 1);
        playLifeSound();
      }

      if (gameMode === 'classic' && newScore >= 3000) {
        unlockMode('speed');
      }

      if (gameMode === 'speed' && newScore >= 100) {
        unlockMode('hard');
      }

      if (gameMode === 'hard' && newScore >= 7500) {
        unlockMode('endless-classic');
        unlockMode('endless-speedy');
        unlockMode('endless-hard');
      }

      if (gameMode === 'endless-hard' && newScore >= 10000) {
        unlockMode('uncompromising');
      }

      if (gameMode === 'speed' || gameMode === 'endless-speedy') {
        const speedUpIncrement = 50;
        const speedUpPercent = gameMode === 'endless-speedy' ? 0.9 : 0.95;

        if (Math.floor(newScore / speedUpIncrement) > Math.floor(score / speedUpIncrement)) {
          setCurrentSpeed((prevSpeed) => prevSpeed * speedUpPercent);
        }

        if (Math.floor(newScore / 200) > Math.floor(score / 200)) {
          const savedSpeed = currentSpeed * speedUpPercent;
          setCurrentSpeed(INITIAL_SPEED);
          setIsSlowdown(true);

          if (slowdownTimerRef.current) window.clearTimeout(slowdownTimerRef.current);

          slowdownTimerRef.current = window.setTimeout(() => {
            setCurrentSpeed(savedSpeed);
            setIsSlowdown(false);
          }, 7000);
        }
      }

      if (gameMode === 'hard' || gameMode === 'endless-hard') {
        const boostInterval = gameMode === 'hard' ? 800 : 700;

        if (Math.floor(newScore / boostInterval) > Math.floor(score / boostInterval)) {
          const savedSpeed = currentSpeed;
          setCurrentSpeed(INITIAL_SPEED / 2); // 200% speed
          setIsSpeedBoost(true);

          if (speedBoostTimerRef.current) window.clearTimeout(speedBoostTimerRef.current);

          speedBoostTimerRef.current = window.setTimeout(() => {
            setCurrentSpeed(savedSpeed);
            setIsSpeedBoost(false);
          }, 6000);
        }
      }

      if (gameMode === 'uncompromising') {
        if (Math.floor(newScore / 250) > Math.floor(score / 250)) {
          const savedSpeed = currentSpeed;
          setCurrentSpeed(INITIAL_SPEED / 2.5); // 250% speed
          setIsSpeedBoost(true);

          if (speedBoostTimerRef.current) window.clearTimeout(speedBoostTimerRef.current);

          speedBoostTimerRef.current = window.setTimeout(() => {
            setCurrentSpeed(savedSpeed);
            setIsSpeedBoost(false);
          }, 6000);
        }

        // Check for completion at 10,000 points
        if (newScore >= 10000 && score < 10000) {
          setGameOver(true);
          setIsPlaying(false);
          updateHighScore(gameMode, newScore);
          // Show victory message
          setTimeout(() => {
            alert('ðŸŽ‰ UNCOMPROMISING MODE COMPLETED! YOU ARE A LEGEND! ðŸŽ‰');
          }, 100);
          return;
        }
      }

      setFood(generateFood());
    } else {
      newSnake.pop();
    }

    setSnake(newSnake);
  }, [snake, direction, food, gameOver, isPlaying, generateFood, score, lives, gameMode, currentSpeed, showRevive]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const handleKeyPress = (e: KeyboardEvent) => {
      if ((e as any).key === ' ') {
        e.preventDefault();
        handleSpacePress();
        return;
      }

      if (!isPlaying && (e as any).key.startsWith('Arrow')) {
        setIsPlaying(true);
      }

      switch ((e as any).key) {
        case 'ArrowUp':
          if (direction.y === 0) setDirection({ x: 0, y: -1 });
          break;
        case 'ArrowDown':
          if (direction.y === 0) setDirection({ x: 0, y: 1 });
          break;
        case 'ArrowLeft':
          if (direction.x === 0) setDirection({ x: -1, y: 0 });
          break;
        case 'ArrowRight':
          if (direction.x === 0) setDirection({ x: 1, y: 0 });
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [direction, isPlaying, gameOver, showRevive, lives, gameState]);

  useEffect(() => {
    if (gameState !== 'playing') return;
    const interval = setInterval(moveSnake, currentSpeed);
    return () => clearInterval(interval);
  }, [moveSnake, gameState, currentSpeed]);

  if (gameState === 'customize') {
    const saveCustomization = async () => {
      try {
        await safeSet('snake-customization', JSON.stringify({
          color: snakeColor,
          pattern: snakePattern
        }));
      } catch (e) {
        console.error('Failed to save customization', e);
      }
      setGameState('menu');
    };

    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-900 p-4">
        <div className="max-w-2xl w-full">
          <div className="text-center mb-8">
            <div className="flex justify-center mb-4">
              <svg className="w-24 h-24 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" />
              </svg>
            </div>
            <h1 className="text-4xl font-bold text-purple-400 mb-2">Customize Snake</h1>
            <p className="text-xl text-gray-400">Make it your own!</p>
          </div>

          <div className="bg-gray-800 rounded-lg p-6 border-2 border-purple-500 mb-6">
            <h2 className="text-2xl font-bold text-purple-400 mb-4">Snake Color</h2>
            <div className="grid grid-cols-5 gap-3 mb-6">
              {Object.entries(COLORS).map(([colorName, colorValue]) => (
                <button
                  key={colorName}
                  onClick={() => setSnakeColor(colorName as keyof typeof COLORS)}
                  className={`h-16 rounded-lg border-4 transition ${snakeColor === colorName ? 'border-white scale-110' : 'border-gray-600'}`}
                  style={{ backgroundColor: colorValue }}
                >
                  <span className="text-white font-bold text-xs capitalize">{colorName}</span>
                </button>
              ))}
            </div>

            <h2 className="text-2xl font-bold text-purple-400 mb-4">Snake Pattern</h2>
            <div className="grid grid-cols-4 gap-3">
              {Object.entries(PATTERNS).map(([patternName, patternSymbol]) => (
                <button
                  key={patternName}
                  onClick={() => setSnakePattern(patternName as keyof typeof PATTERNS)}
                  className={`h-16 rounded-lg border-4 transition flex items-center justify-center ${snakePattern === patternName ? 'border-white scale-110 bg-gray-700' : 'border-gray-600 bg-gray-800'}`}
                >
                  <div className="text-center">
                    <div className="text-3xl mb-1">{patternSymbol}</div>
                    <div className="text-xs text-gray-300 capitalize">{patternName}</div>
                  </div>
                </button>
              ))}
            </div>
          </div>

          <div className="bg-gray-800 rounded-lg p-6 border-2 border-purple-500 mb-6">
            <h2 className="text-xl font-bold text-purple-400 mb-4">Preview</h2>
            <div className="flex justify-center items-center space-x-2">
              {[0, 1, 2, 3, 4].map(i => (
                <div
                  key={i}
                  className="w-12 h-12 rounded flex items-center justify-center text-2xl"
                  style={{ backgroundColor: COLORS[snakeColor] }}
                >
                  {PATTERNS[snakePattern]}
                </div>
              ))}
            </div>
          </div>

          <div className="flex justify-center space-x-4">
            <button onClick={saveCustomization} className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg transition">
              Save & Return
            </button>
            <button onClick={() => setGameState('menu')} className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-8 rounded-lg transition">
              Cancel
            </button>
          </div>
        </div>
      </div>
    );
  }

  // --- Menu and Game screens are preserved as in original file (omitted here to keep message size reasonable)
  // If you copied the three parts above, continue by pasting the remaining menu and game render sections from your original file here.
  // (However, the previous uploaded version already contained these; if you need the exact final chunk I will paste the remainder too.)
}
